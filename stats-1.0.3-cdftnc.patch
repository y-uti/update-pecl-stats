diff -u -r stats-1.0.3/cdflib.h stats-1.0.3.patched.cdftnc/cdflib.h
--- stats-1.0.3/cdflib.h	1994-03-04 13:35:58.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/cdflib.h	2014-05-14 06:23:13.108243315 +0900
@@ -27,6 +27,7 @@
 void cdfnor(int*,double*,double*,double*,double*,double*,int*,double*);
 void cdfpoi(int*,double*,double*,double*,double*,int*,double*);
 void cdft(int*,double*,double*,double*,double*,int*,double*);
+void cdftnc(int*,double*,double*,double*,double*,double*,int*,double*);
 void cumbet(double*,double*,double*,double*,double*,double*);
 void cumbin(double*,double*,double*,double*,double*,double*);
 void cumchi(double*,double*,double*,double*);
@@ -38,6 +39,7 @@
 void cumnor(double*,double*,double*);
 void cumpoi(double*,double*,double*,double*);
 void cumt(double*,double*,double*,double*);
+void cumtnc(double*,double*,double*,double*,double*);
 double dbetrm(double*,double*);
 double devlpl(double [],int*,double*);
 double dexpm1(double*);
diff -u -r stats-1.0.3/config.m4 stats-1.0.3.patched.cdftnc/config.m4
--- stats-1.0.3/config.m4	2012-12-10 21:03:05.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/config.m4	2014-05-14 06:23:13.108243315 +0900
@@ -5,5 +5,5 @@
 [  --enable-stats           Enable statistics support])
 
 if test "$PHP_STATS" != "no"; then
-  PHP_NEW_EXTENSION(stats, php_stats.c com.c dcdflib.c ipmpar.c linpack.c randlib.c , $ext_shared)
+  PHP_NEW_EXTENSION(stats, php_stats.c com.c dcdflib.c ipmpar.c linpack.c ranlib.c , $ext_shared)
 fi
diff -u -r stats-1.0.3/config.w32 stats-1.0.3.patched.cdftnc/config.w32
--- stats-1.0.3/config.w32	2012-12-10 21:03:05.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/config.w32	2014-05-14 06:23:13.108243315 +0900
@@ -4,6 +4,6 @@
 ARG_ENABLE("stats", "statistics support", "no");
 
 if (PHP_STATS != "no") {
-	EXTENSION('stats', 'php_stats.c com.c dcdflib.c ipmpar.c linpack.c randlib.c fd_e_lgamma_r.c fd_e_log.c fd_k_cos.c fd_k_sin.c fd_w_lgamma.c');
+	EXTENSION('stats', 'php_stats.c com.c dcdflib.c ipmpar.c linpack.c ranlib.c e_lgamma_r.c e_log.c k_cos.c k_sin.c w_lgamma.c');
 }
 
diff -u -r stats-1.0.3/dcdflib.c stats-1.0.3.patched.cdftnc/dcdflib.c
--- stats-1.0.3/dcdflib.c	1994-04-28 23:38:09.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/dcdflib.c	2014-05-14 06:23:13.108243315 +0900
@@ -4663,6 +4663,221 @@
 #undef inf
 #undef maxdf
 }
+void cdftnc(int *which,double *p,double *q,double *t,double *df,
+            double *pnonc,int *status,double *bound)
+/**********************************************************************
+ 
+   void cdftnc(int *which,double *p,double *q,double *t,double *df,
+               double *pnonc,int *status,double *bound)
+
+                Cumulative Distribution Function
+                   Non-Central T distribution
+ 
+                                Function
+ 
+      Calculates any one parameter of the noncentral t distribution give
+      values for the others.
+ 
+                                Arguments
+ 
+      WHICH --> Integer indicating which  argument
+                values is to be calculated from the others.
+                Legal range: 1..3
+                iwhich = 1 : Calculate P and Q from T,DF,PNONC
+                iwhich = 2 : Calculate T from P,Q,DF,PNONC
+                iwhich = 3 : Calculate DF from P,Q,T
+                iwhich = 4 : Calculate PNONC from P,Q,DF,T
+ 
+         P <--> The integral from -infinity to t of the noncentral t-den
+               Input range: (0,1].
+ 
+         Q <--> 1-P.
+               Input range: (0, 1].
+                P + Q = 1.0.
+ 
+         T <--> Upper limit of integration of the noncentral t-density.
+                Input range: ( -infinity, +infinity).
+                Search range: [ -1E100, 1E100 ]
+ 
+         DF <--> Degrees of freedom of the noncentral t-distribution.
+                 Input range: (0 , +infinity).
+                 Search range: [1e-100, 1E10]
+ 
+      PNONC <--> Noncentrality parameter of the noncentral t-distributio
+                 Input range: [-infinity , +infinity).
+                 Search range: [-1e4, 1E4]
+ 
+      STATUS <-- 0 if calculation completed correctly
+                -I if input parameter number I is out of range
+                 1 if answer appears to be lower than lowest
+                   search bound
+                 2 if answer appears to be higher than greatest
+                   search bound
+                 3 if P + Q .ne. 1
+ 
+      BOUND <-- Undefined if STATUS is 0
+ 
+                Bound exceeded by parameter number I if STATUS
+                is negative.
+ 
+                Lower search bound if STATUS is 1.
+ 
+                Upper search bound if STATUS is 2.
+ 
+                                 Method
+ 
+      Upper tail    of  the  cumulative  noncentral t is calculated usin
+      formulae  from page 532  of Johnson, Kotz,  Balakrishnan, Coninuou
+      Univariate Distributions, Vol 2, 2nd Edition.  Wiley (1995)
+ 
+      Computation of other parameters involve a seach for a value that
+      produces  the desired  value  of P.   The search relies  on  the
+      monotinicity of P with the other parameter.
+ 
+**********************************************************************/
+{
+#define tent4 1.0e4
+#define tol 1.0e-8
+#define atol 1.0e-50
+#define zero 1.0e-100
+#define one ( 1.0e0 - 1.0e-16 )
+#define inf 1.0e100
+static double K3 = 0.5e0;
+static double K4 = 5.0e0;
+static double ccum,cum,fx;
+static unsigned long qhi,qleft;
+static double T1,T2,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14;
+/*
+     ..
+     .. Executable Statements ..
+*/
+    if(!(*which < 1 || *which > 4)) goto S30;
+    if(!(*which < 1)) goto S10;
+    *bound = 1.0e0;
+    goto S20;
+S10:
+    *bound = 5.0e0;
+S20:
+    *status = -1;
+    return;
+S30:
+    if(*which == 1) goto S70;
+    if(!(*p < 0.0e0 || *p > one)) goto S60;
+    if(!(*p < 0.0e0)) goto S40;
+    *bound = 0.0e0;
+    goto S50;
+S40:
+    *bound = one;
+S50:
+    *status = -2;
+    return;
+S70:
+S60:
+    if(*which == 3) goto S90;
+    if(!(*df <= 0.0e0)) goto S80;
+    *bound = 0.0e0;
+    *status = -5;
+    return;
+S90:
+S80:
+    if(*which == 4) goto S100;
+S100:
+    if(1 == *which) {
+        cumtnc(t,df,pnonc,p,q);
+        *status = 0;
+    }
+    else if(2 == *which) {
+        *t = 5.0e0;
+        T1 = -inf;
+        T2 = inf;
+        T5 = atol;
+        T6 = tol;
+        dstinv(&T1,&T2,&K3,&K3,&K4,&T5,&T6);
+        *status = 0;
+        dinvr(status,t,&fx,&qleft,&qhi);
+S110:
+        if(!(*status == 1)) goto S120;
+        cumtnc(t,df,pnonc,&cum,&ccum);
+        fx = cum - *p;
+        dinvr(status,t,&fx,&qleft,&qhi);
+        goto S110;
+S120:
+        if(!(*status == -1)) goto S150;
+        if(!qleft) goto S130;
+        *status = 1;
+        *bound = -inf;
+        goto S140;
+S130:
+        *status = 2;
+        *bound = inf;
+S150:
+S140:
+        ;
+    }
+    else if(3 == *which) {
+        *df = 5.0e0;
+        T7 = zero;
+        T8 = tent4;
+        T9 = atol;
+        T10 = tol;
+        dstinv(&T7,&T8,&K3,&K3,&K4,&T9,&T10);
+        *status = 0;
+        dinvr(status,df,&fx,&qleft,&qhi);
+S160:
+        if(!(*status == 1)) goto S170;
+        cumtnc(t,df,pnonc,&cum,&ccum);
+        fx = cum - *p;
+        dinvr(status,df,&fx,&qleft,&qhi);
+        goto S160;
+S170:
+        if(!(*status == -1)) goto S200;
+        if(!qleft) goto S180;
+        *status = 1;
+        *bound = zero;
+        goto S190;
+S180:
+        *status = 2;
+        *bound = inf;
+S200:
+S190:
+        ;
+    }
+    else if(4 == *which) {
+        *pnonc = 5.0e0;
+        T11 = -tent4;
+        T12 = tent4;
+        T13 = atol;
+        T14 = tol;
+        dstinv(&T11,&T12,&K3,&K3,&K4,&T13,&T14);
+        *status = 0;
+        dinvr(status,pnonc,&fx,&qleft,&qhi);
+S210:
+        if(!(*status == 1)) goto S220;
+        cumtnc(t,df,pnonc,&cum,&ccum);
+        fx = cum - *p;
+        dinvr(status,pnonc,&fx,&qleft,&qhi);
+        goto S210;
+S220:
+        if(!(*status == -1)) goto S250;
+        if(!qleft) goto S230;
+        *status = 1;
+        *bound = 0.0e0;
+        goto S240;
+S230:
+        *status = 2;
+        *bound = tent4;
+S240:
+        ;
+    }
+S250:
+    return;
+#undef tent4
+#undef tol
+#undef atol
+#undef zero
+#undef one
+#undef inf
+}
 void cumbet(double *x,double *y,double *a,double *b,double *cum,
 	    double *ccum)
 /*
@@ -5770,6 +5985,237 @@
 S20:
     return;
 }
+void cumtnc(double *t,double *df,double *pnonc,double *cum,
+            double *ccum)
+/**********************************************************************
+ 
+     void cumtnc(double *t,double *df,double *pnonc,double *cum,
+                 double *ccum)
+ 
+                  CUMulative Non-Central T-distribution
+ 
+ 
+                               Function
+ 
+ 
+      Computes the integral from -infinity to T of the non-central
+      t-density.
+ 
+ 
+                               Arguments
+ 
+ 
+      T --> Upper limit of integration of the non-central t-density.
+ 
+      DF --> Degrees of freedom of the non-central t-distribution.
+ 
+      PNONC --> Non-centrality parameter of the non-central t distibutio
+ 
+      CUM <-- Cumulative t-distribution.
+ 
+      CCUM <-- Compliment of Cumulative t-distribution.
+ 
+ 
+                               Method
+ 
+      Upper tail    of  the  cumulative  noncentral t   using
+      formulae from page 532  of Johnson, Kotz,  Balakrishnan, Coninuous
+      Univariate Distributions, Vol 2, 2nd Edition.  Wiley (1995)
+ 
+      This implementation starts the calculation at i = lambda,
+      which is near the largest Di.  It then sums forward and backward.
+**********************************************************************/
+{
+#define one 1.0e0
+#define zero 0.0e0
+#define half 0.5e0
+#define two 2.0e0
+#define onep5 1.5e0
+#define conv 1.0e-7
+#define tiny 1.0e-10
+static double alghdf,b,bb,bbcent,bcent,cent,d,dcent,dpnonc,dum1,dum2,e,ecent,
+    halfdf,lambda,lnomx,lnx,omx,pnonc2,s,scent,ss,sscent,t2,term,tt,twoi,x,xi,
+    xlnd,xlne;
+static int ierr;
+static unsigned long qrevs;
+static double T1,T2,T3,T4,T5,T6,T7,T8,T9,T10;
+/*
+     ..
+     .. Executable Statements ..
+*/
+/*
+     Case pnonc essentially zero
+*/
+    if(fabs(*pnonc) <= tiny) {
+        cumt(t,df,cum,ccum);
+        return;
+    }
+    qrevs = *t < zero;
+    if(qrevs) {
+        tt = -*t;
+        dpnonc = -*pnonc;
+    }
+    else  {
+        tt = *t;
+        dpnonc = *pnonc;
+    }
+    pnonc2 = dpnonc * dpnonc;
+    t2 = tt * tt;
+    if(fabs(tt) <= tiny) {
+        T1 = -*pnonc;
+        cumnor(&T1,cum,ccum);
+        return;
+    }
+    lambda = half * pnonc2;
+    x = *df / (*df + t2);
+    omx = one - x;
+    lnx = log(x);
+    lnomx = log(omx);
+    halfdf = half * *df;
+    alghdf = gamln(&halfdf);
+/*
+     ******************** Case i = lambda
+*/
+    cent = fifidint(lambda);
+    if(cent < one) cent = one;
+/*
+     Compute d=T(2i) in log space and offset by exp(-lambda)
+*/
+    T2 = cent + one;
+    xlnd = cent * log(lambda) - gamln(&T2) - lambda;
+    dcent = exp(xlnd);
+/*
+     Compute e=t(2i+1) in log space offset by exp(-lambda)
+*/
+    T3 = cent + onep5;
+    xlne = (cent + half) * log(lambda) - gamln(&T3) - lambda;
+    ecent = exp(xlne);
+    if(dpnonc < zero) ecent = -ecent;
+/*
+     Compute bcent=B(2*cent)
+*/
+    T4 = cent + half;
+    bratio(&halfdf,&T4,&x,&omx,&bcent,&dum1,&ierr);
+/*
+     compute bbcent=B(2*cent+1)
+*/
+    T5 = cent + one;
+    bratio(&halfdf,&T5,&x,&omx,&bbcent,&dum2,&ierr);
+/*
+     Case bcent and bbcent are essentially zero
+     Thus t is effectively infinite
+*/
+    if(bcent + bbcent < tiny) {
+        if(qrevs) {
+            *cum = zero;
+            *ccum = one;
+        }
+        else  {
+            *cum = one;
+            *ccum = zero;
+        }
+        return;
+    }
+/*
+     Case bcent and bbcent are essentially one
+     Thus t is effectively zero
+*/
+    if(dum1 + dum2 < tiny) {
+        T6 = -*pnonc;
+        cumnor(&T6,cum,ccum);
+        return;
+    }
+/*
+     First term in ccum is D*B + E*BB
+*/
+    *ccum = dcent * bcent + ecent * bbcent;
+/*
+     compute s(cent) = B(2*(cent+1)) - B(2*cent))
+*/
+    T7 = halfdf + cent + half;
+    T8 = cent + onep5;
+    scent = gamln(&T7) - gamln(&T8) - alghdf + halfdf * lnx + (cent + half) * 
+      lnomx;
+    scent = exp(scent);
+/*
+     compute ss(cent) = B(2*cent+3) - B(2*cent+1)
+*/
+    T9 = halfdf + cent + one;
+    T10 = cent + two;
+    sscent = gamln(&T9) - gamln(&T10) - alghdf + halfdf * lnx + (cent + one) * 
+      lnomx;
+    sscent = exp(sscent);
+/*
+     ******************** Sum Forward
+*/
+    xi = cent + one;
+    twoi = two * xi;
+    d = dcent;
+    e = ecent;
+    b = bcent;
+    bb = bbcent;
+    s = scent;
+    ss = sscent;
+S10:
+    b += s;
+    bb += ss;
+    d = lambda / xi * d;
+    e = lambda / (xi + half) * e;
+    term = d * b + e * bb;
+    *ccum += term;
+    s = s * omx * (*df + twoi - one) / (twoi + one);
+    ss = ss * omx * (*df + twoi) / (twoi + two);
+    xi += one;
+    twoi = two * xi;
+    if(fabs(term) > conv * *ccum) goto S10;
+/*
+     ******************** Sum Backward
+*/
+    xi = cent;
+    twoi = two * xi;
+    d = dcent;
+    e = ecent;
+    b = bcent;
+    bb = bbcent;
+    s = scent * (one + twoi) / ((*df + twoi - one) * omx);
+    ss = sscent * (two + twoi) / ((*df + twoi) * omx);
+S20:
+    b -= s;
+    bb -= ss;
+    d *= (xi / lambda);
+    e *= ((xi + half) / lambda);
+    term = d * b + e * bb;
+    *ccum += term;
+    xi -= one;
+    if(xi < half) goto S30;
+    twoi = two * xi;
+    s = s * (one + twoi) / ((*df + twoi - one) * omx);
+    ss = ss * (two + twoi) / ((*df + twoi) * omx);
+    if(fabs(term) > conv * *ccum) goto S20;
+S30:
+    if(qrevs) {
+        *cum = half * *ccum;
+        *ccum = one - *cum;
+    }
+    else  {
+        *ccum = half * *ccum;
+        *cum = one - *ccum;
+    }
+/*
+     Due to roundoff error the answer may not lie between zero and one
+     Force it to do so
+*/
+    *cum = fifdmax1(fifdmin1(*cum,one),zero);
+    *ccum = fifdmax1(fifdmin1(*ccum,one),zero);
+    return;
+#undef one
+#undef zero
+#undef half
+#undef two
+#undef onep5
+#undef conv
+#undef tiny
+}
 double dbetrm(double *a,double *b)
 /*
 **********************************************************************
diff -u -r stats-1.0.3/php_stats.c stats-1.0.3.patched.cdftnc/php_stats.c
--- stats-1.0.3/php_stats.c	2012-12-10 21:03:05.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/php_stats.c	2014-05-14 06:23:13.108243315 +0900
@@ -31,7 +31,7 @@
 #include <string.h>
 #include <ctype.h>
 #include <math.h>
-#include "randlib.h"
+#include "ranlib.h"
 #include "cdflib.h"
 
 #define STATS_PI 3.14159265358979323846
diff -u -r stats-1.0.3/ranlib.c stats-1.0.3.patched.cdftnc/ranlib.c
--- stats-1.0.3/ranlib.c	1994-04-26 23:49:08.000000000 +0900
+++ stats-1.0.3.patched.cdftnc/ranlib.c	2014-05-14 06:23:13.108243315 +0900
@@ -5,7 +5,7 @@
 #define ABS(x) ((x) >= 0 ? (x) : -(x))
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
-void ftnstop(char*);
+extern void ftnstop(char*);
 float genbet(float aa,float bb)
 /*
 **********************************************************************
@@ -1887,13 +1887,3 @@
     return -num;
 else return num;
 }
-/************************************************************************
-FTNSTOP:
-Prints msg to standard error and then exits
-************************************************************************/
-void ftnstop(char* msg)
-/* msg - error message */
-{
-  if (msg != NULL) fprintf(stderr,"%s\n",msg);
-  exit(0);
-}
